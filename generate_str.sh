#!/bin/bash

rtp_file="parameters/forcefield/charmm36_dyes.ff/merged.rtp"

# First scan for all residue names
echo "Scanning for available residues..."
residues=()
while IFS= read -r line; do
    if [[ $line =~ ^\[[[:space:]]*([A-Za-z0-9]+)[[:space:]]*\] ]]; then
        section_name="${BASH_REMATCH[1]}"
        if [[ $section_name != "atoms" && $section_name != "bonds" && $section_name != "impropers" && $section_name != "bondedtypes" ]]; then
            residues+=("$section_name")
        fi
    fi
done < "$rtp_file"

# Print residues in groups of 10
total_residues=${#residues[@]}
echo "Available residues:"
for ((i=0; i<total_residues; i+=10)); do
    echo "${residues[@]:i:10}" | tr ' ' ' '
    if ((i+10 < total_residues)); then
        read -p "Show next 10? (y/n): " choice
        if [[ $choice != "y" ]]; then
            break
        fi
    fi
done

# Interactive prompt for resname
read -p "Enter residue name: " resname

# Validate resname
if [[ ! " ${residues[*]} " =~ " ${resname} " ]]; then
    echo "Error: Residue $resname not found in RTP file"
    exit 1
fi

pdb_dirs=("parameters/forcefield/pdbs/dyes" "parameters/forcefield/pdbs/with_linker")
output_file="${resname}.str"

# Find PDB file containing the resname in either directory
pdb_file=""
for dir in "${pdb_dirs[@]}"; do
    if [ -d "$dir" ]; then
        found_file=$(grep -l " $resname " "$dir"/*.pdb)
        if [ -n "$found_file" ]; then
            pdb_file="$found_file"
            break
        fi
    fi
done

if [ -z "$pdb_file" ]; then
    echo "Error: No PDB file found containing resname $resname in either dyes or with_linker directory"
    exit 1
fi

echo "Found PDB file: $pdb_file"

# Create output STR file and tem.prm file
cat > $output_file << EOF
* Toppar stream file generated by
* generate_str.sh using $pdb_file and $rtp_file
*

read rtf card append
* Topologies generated by
* generate_str.sh using $pdb_file and $rtp_file
*

RESI $resname          0.000 ! param penalty=   0.000 ; charge penalty=   0.000
GROUP            ! CHARGE   CH_PENALTY
EOF

# Create tem.prm file
tem_prm="${resname}.tem.prm"
echo "* Bond parameters for $resname" > "$tem_prm"
echo "BONDS" >> "$tem_prm"

# Initialize atom type arrays
atom_names=()
atom_types=()

# Parse RTP file for atom information
in_residue=false
in_atoms=false
in_bonds=false
in_impropers=false
atoms_section_done=false
line_number=0

while IFS= read -r line; do
    line_number=$((line_number + 1))
    
    # Skip empty lines and comments
    if [[ -z "$line" || $line =~ ^[[:space:]]*# ]]; then
        continue
    fi
    
    # Check for any new residue section - if we're in a section and hit a new residue, stop
    if [[ $line =~ ^\[[[:space:]]*[A-Za-z0-9]+[[:space:]]*\] ]] && [[ $in_residue == true ]] && [[ ! $line =~ ^\[[[:space:]]*$resname[[:space:]]*\] ]] && [[ ! $line =~ ^\[[[:space:]]*atoms[[:space:]]*\] ]] && [[ ! $line =~ ^\[[[:space:]]*bonds[[:space:]]*\] ]] && [[ ! $line =~ ^\[[[:space:]]*impropers[[:space:]]*\] ]]; then
        break
    fi
    
    # Check for residue section
    if [[ $line =~ ^\[[[:space:]]*$resname[[:space:]]*\] ]]; then
        in_residue=true
        echo "Found residue section"
        continue
    fi
    
    # Only process if we're in the correct residue
    if ! $in_residue; then
        continue
    fi
    
    # Check for impropers section first
    if [[ $line =~ ^[[:space:]]*\[[[:space:]]*impropers[[:space:]]*\] ]]; then
        in_impropers=true
        echo "Found impropers section"
        continue
    fi
    
    # Check for atoms section
    if [[ $line =~ ^[[:space:]]*\[[[:space:]]*atoms[[:space:]]*\] ]]; then
        in_atoms=true
        echo "Found atoms section"
        continue
    fi
    
    # Check for bonds section
    if [[ $line =~ ^[[:space:]]*\[[[:space:]]*bonds[[:space:]]*\] ]]; then
        in_bonds=true
        echo "Found bonds section"
        continue
    fi
    
    # Process atom lines and build arrays
    if [[ $in_atoms == true && $line =~ ^[[:space:]]*[A-Za-z0-9]+[[:space:]]+[A-Za-z0-9]+[[:space:]]+[-0-9.]+ ]]; then
        # Extract atom information
        atom_name=$(echo "$line" | awk '{print $1}')
        atom_type=$(echo "$line" | awk '{print $2}')
        charge=$(echo "$line" | awk '{print $3}')
        
        # Store in arrays
        atom_names+=("$atom_name")
        atom_types+=("$atom_type")
        
        # Skip if any field is empty or invalid
        if [[ -z "$atom_name" || -z "$atom_type" || -z "$charge" ]]; then
            continue
        fi
        
        # Check if atom exists in PDB
        if ! grep -q "^\(ATOM\|HETATM\).*$atom_name.*$resname" "$pdb_file"; then
            echo "Warning: Atom $atom_name not found in PDB file"
            read -p "Continue? (y/n): " choice
            if [[ $choice != "y" ]]; then
                exit 1
            fi
        fi
        
        # Write atom line to STR file
        printf "ATOM %-8s %-8s %8.4f !    0.000\n" "$atom_name" "$atom_type" "$charge" >> $output_file
    fi
    
    # Process bond lines using arrays
    if [[ $in_bonds == true && $line =~ ^[[:space:]]+[A-Za-z0-9]+[[:space:]]+[A-Za-z0-9]+ ]]; then
        atom1=$(echo "$line" | awk '{print $1}')
        atom2=$(echo "$line" | awk '{print $2}')
        
        # Get atom types from arrays
        atom1_type=""
        atom2_type=""
        for i in "${!atom_names[@]}"; do
            if [[ "${atom_names[$i]}" == "$atom1" ]]; then
                atom1_type="${atom_types[$i]}"
            fi
            if [[ "${atom_names[$i]}" == "$atom2" ]]; then
                atom2_type="${atom_types[$i]}"
            fi
        done
        
        if [[ -z "$atom1_type" || -z "$atom2_type" ]]; then
            echo "Error: Could not find atom types for $atom1 or $atom2"
            exit 1
        fi
        
        #echo "Looking for bond: $atom1_type $atom2_type"
        
        # Search in toppar_c46_jul22 prm files
        found_param=false
        for prm_file in toppar_c46_jul22/*.prm; do
            if [ -f "$prm_file" ]; then
                line_num=$(grep -n "$atom1_type.*$atom2_type\|$atom2_type.*$atom1_type" "$prm_file" | head -n 1 | cut -d: -f1)
                if [ -n "$line_num" ]; then
                    echo "Found match in $prm_file at line $line_num: $atom1_type $atom2_type"
                    param_line=$(grep -m 1 "$atom1_type.*$atom2_type\|$atom2_type.*$atom1_type" "$prm_file")
                    if ! grep -q "$param_line" "$tem_prm"; then
                        echo "$param_line" >> "$tem_prm"
                    fi
                    printf "BOND %-8s %-8s ! %s\n" "$atom1" "$atom2" "$(basename "$prm_file")" >> $output_file
                    found_param=true
                    break
                fi
            fi
        done
        
        # If not found in prm files, look in ffdyesbonded.itp
        if [ "$found_param" = false ]; then
            line_num=$(grep -n "$atom1_type.*$atom2_type\|$atom2_type.*$atom1_type" "parameters/forcefield/charmm36_dyes.ff/ffdyesbonded.itp" | head -n 1 | cut -d: -f1)
            if [ -n "$line_num" ]; then
                #echo "Found match in ffbonded.itp at line $line_num: $atom1_type $atom2_type"
                param_line=$(grep -m 1 "$atom1_type.*$atom2_type\|$atom2_type.*$atom1_type" "parameters/forcefield/charmm36_dyes.ff/ffdyesbonded.itp")
                if ! grep -q "$param_line" "$tem_prm"; then
                    echo "$param_line" >> "$tem_prm"
                fi
                printf "BOND %-8s %-8s ! ffbonded.itp\n" "$atom1" "$atom2" >> $output_file
            else
                #echo "No match found for $atom1_type $atom2_type"
                exit 1
            fi
        fi
    fi
    
    # Process improper lines - handle both spaces and tabs
    if [[ $in_impropers == true ]]; then
        if [[ $line =~ ^[[:space:]]*[A-Za-z0-9]+[[:space:]]+[A-Za-z0-9]+[[:space:]]+[A-Za-z0-9]+[[:space:]]+[A-Za-z0-9]+ ]]; then
            atom1=$(echo "$line" | awk '{print $1}')
            atom2=$(echo "$line" | awk '{print $2}')
            atom3=$(echo "$line" | awk '{print $3}')
            atom4=$(echo "$line" | awk '{print $4}')
            printf "IMPR %-8s %-8s %-8s %-8s\n" "$atom1" "$atom2" "$atom3" "$atom4" >> $output_file
        fi
    fi
    
done < "$rtp_file"

cat >> $output_file << EOF

END

read param card flex append
* Parameters generated by analogy by
* CHARMM General Force Field (CGenFF) program version 2.4.0
*

! Penalties lower than 10 indicate the analogy is fair; penalties between 10
! and 50 mean some basic validation is recommended; penalties higher than
! 50 indicate poor analogy and mandate extensive validation/optimization.

BONDS

ANGLES

DIHEDRALS

IMPROPERS

END
RETURN
EOF

echo "Generated STR file: $output_file" 